---
title: Caching Images
description: Getting to know how the Caching works with Nuxt OG Image.
---

In cases
where you need to generate images at runtime, Nuxt OG Image provides a caching layer to
reduce the load on your server.

This caching layer uses SWR caching is enabled by default with a cache time of 72 hours.

## Cache Storage

Nitro caching by default will use the memory as a cache storage. This means that if you restart your server, the cache will be cleared.

It's recommended to set a persistent cache storage. This can be done using the `runtimeCacheStorage` option.

The option takes the same configuration as the Nuxt `nitro.storage` option.
See the [Nitro Storage Layer](https://nitro.unjs.io/guide/storage) documentation for more details.

For example:

```ts
export default defineNuxtConfig({
  ogImage: {
    // cloudflare kv binding example, set your own config
    runtimeCacheStorage: {
      driver: 'cloudflare-kv-binding',
      binding: 'OG_IMAGE_CACHE'
    }
  }
})
```

## Cache Key Customization

By default, Nuxt OG Image includes the package version in the cache key prefix. This means that when you update the package, all cache entries will be invalidated. Additionally, each unique URL query parameter creates a unique cache entry.

You can customize this behavior with the following options:

### Stable Cache Key

If you want to maintain your cache across package updates, you can specify a custom `key` value:

```ts
export default defineNuxtConfig({
  ogImage: {
    // Custom cache key to maintain cache across package updates
    key: 'my-app-og-images',

    // Other cache options
    runtimeCacheStorage: {
      driver: 'redis',
      // ...
    }
  }
})
```

### Ignoring Query Parameters

If your OG images don't depend on URL query parameters, you can ignore them to prevent duplicate cache entries:

```ts
export default defineNuxtConfig({
  ogImage: {
    // Ignore query parameters when generating cache keys
    cacheIgnoreQuery: true,

    // Other options...
    runtimeCacheStorage: {
      // ...
    }
  }
})
```

### Custom Cache Key Handler

For advanced use cases, you can provide a custom function to generate cache keys:

```ts
export default defineNuxtConfig({
  ogImage: {
    // Full control over cache key generation
    cacheKeyHandler: (path, event) => {
      // Example: Only include 'locale' query parameter in the cache key
      const query = getQuery(event)
      const relevantParams = { locale: query.locale }

      return `${path}:${hash(relevantParams)}`
    },

    // Other options...
  }
})
```

## Cache Debugging

Nuxt OG Image provides several tools to help debug caching issues:

### Debug Headers

When in development mode or when `debug: true` is set in your config, Nuxt OG Image adds helpful debug headers to responses:

- `X-OG-Image-Cache-Key`: The exact cache key used for the image
- `X-OG-Image-Cache-Base`: The cache base/prefix being used
- `X-OG-Image-Cache-Enabled`: Whether caching is enabled
- `X-OG-Image-Cache-Ignore-Query`: Whether query parameters are being ignored

These headers can help troubleshoot issues with cache key generation and configuration.

### Cache Statistics Endpoint

A debug endpoint is available at `/__og-image__/debug/cache-stats` that provides detailed information about your cache:

```ts
export default defineNuxtConfig({
  ogImage: {
    // Enable debug mode to access the cache statistics endpoint
    debug: true,

    // Other options...
  }
})
```

This endpoint returns:
- Current cache configuration
- Statistics about cache usage
- Sample of recent cache keys

This can be particularly helpful when diagnosing cache efficiency and behavior in production-like environments.

## Cache Time

You can change the cache time of an image by providing `cacheMaxAgeSeconds` in milliseconds when defining the image.

```ts
defineOgImage({
  cacheMaxAgeSeconds: 30 // 30 seconds
})
```

Alternatively, you can change the default cache time in your nuxt.config.

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  ogImage: {
    defaults: {
      cacheMaxAgeSeconds: 60 * 60 * 24 * 7 // 7 days
    }
  }
})
```

## Persistent Cache for CI Deployments

When deploying your application in CI environments, the cache is typically lost between deployments. To solve this problem, Nuxt OG Image provides a way to persist your OG image cache in the `node_modules/.cache` directory, which is commonly preserved between CI builds.

To enable this feature, set the `persistentCache` option to `true` in your `nuxt.config.ts`:

```ts
export default defineNuxtConfig({
  ogImage: {
    // Store OG image cache in node_modules/.cache
    persistentCache: true,

    // For best results, also use a consistent cache key
    key: 'my-app-og-cache',

    // Other options...
  }
})
```

### How It Works

When `persistentCache` is enabled:

1. Nuxt OG Image automatically detects if you're running in a CI environment
2. In CI environments, it locates your project's `node_modules/.cache` directory and uses it for caching
3. In non-CI environments, it falls back to the regular memory cache for better performance
4. OG images are cached as files in the cache directory, which survives across CI builds when `node_modules` is cached

:::tip
The persistent cache is automatically enabled only in CI environments. In local development, it defaults to using the in-memory cache for better performance.
:::

:::info
If you want to test the persistent cache in a non-CI environment, you can force it by setting a CI environment variable like `CI=true` when running your application.
:::

### CI Configuration Tips

For this feature to work effectively in CI environments, make sure your CI configuration caches the `node_modules` directory. Here are examples for common CI platforms:

#### GitHub Actions

```yaml
# .github/workflows/deploy.yml
steps:
  - uses: actions/checkout@v3

  - name: Cache dependencies
    uses: actions/cache@v3
    with:
      path: |
        node_modules
        **/node_modules/.cache
      key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
      restore-keys: |
        ${{ runner.os }}-node-

  # Rest of your workflow...
```

#### GitLab CI

```yaml
# .gitlab-ci.yml
cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
    - node_modules/
    - node_modules/.cache/
```

#### CircleCI

```yaml
# .circleci/config.yml
- restore_cache:
    keys:
      - v1-dependencies-{{ checksum "package.json" }}
      - v1-dependencies-

# ...other steps...

- save_cache:
    paths:
      - node_modules
      - node_modules/.cache
    key: v1-dependencies-{{ checksum "package.json" }}
```
